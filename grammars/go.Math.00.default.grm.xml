<?xml version="1.0" standalone="no"?>
<!DOCTYPE grammar SYSTEM "grammar.dtd"[]>
<grammar name="Go" version="5" ext="go" type="">
  <!--Copyright 2014 Google Inc. All rights reserved.-->
  <!--Use of this source code is governed by the Apache 2.0-->
  <!--license that can be found in the LICENSE file.-->
  <!--*******************************************Contributed by Glenn Lewis*******************************************-->
  <!--List of all the mathematical functions supported by GeneXproTools 5.0. All functions must be completely defined.-->
  <!--To generate Carriage Return Line Feeds (CrLf) use the token {CRLF} (curly braces included).-->
  <!--To generate Tabs use the token {TAB} (curly braces included).-->
  <!--Use {CHARX} as an escape for the x in the definition of the functions.-->
  <functions count="318">
    <function idx="0" symbol="+" terminals="2" uniontype="{tempvarname} {symbol}= {member}">(x0+x1)</function>
    <function idx="1" symbol="-" terminals="2" uniontype="{tempvarname} {symbol}= {member}">(x0-x1)</function>
    <function idx="2" symbol="*" terminals="2" uniontype="{tempvarname} {symbol}= {member}">(x0*x1)</function>
    <function idx="3" symbol="/" terminals="2" uniontype="{tempvarname} {symbol}= {member}">(x0/x1)</function>
    <function idx="4" symbol="Mod" terminals="2" uniontype="">gepMod(x0,x1)</function>
    <function idx="5" symbol="Pow" terminals="2" uniontype="">math.Pow(x0,x1)</function>
    <function idx="6" symbol="Sqrt" terminals="1" uniontype="">math.Sqrt(x0)</function>
    <function idx="7" symbol="Exp" terminals="1" uniontype="">math.Exp(x0)</function>
    <function idx="8" symbol="Pow10" terminals="1" uniontype="">math.Pow(10.0,x0)</function>
    <function idx="9" symbol="Ln" terminals="1" uniontype="">math.Log(x0)</function>
    <function idx="10" symbol="Log" terminals="1" uniontype="">math.Log10(x0)</function>
    <function idx="83" symbol="Log2" terminals="2" uniontype="">gepLog2(x0,x1)</function>
    <function idx="12" symbol="Floor" terminals="1" uniontype="">math.Floor(x0)</function>
    <function idx="13" symbol="Ceil" terminals="1" uniontype="">math.Ceil(x0)</function>
    <function idx="14" symbol="Abs" terminals="1" uniontype="">math.Abs(x0)</function>
    <function idx="15" symbol="Inv" terminals="1" uniontype="">(1.0/(x0))</function>
    <function idx="17" symbol="Neg" terminals="1" uniontype="">(-(x0))</function>
    <function idx="16" symbol="Nop" terminals="1" uniontype="">(x0)</function>
    <function idx="76" symbol="X2" terminals="1" uniontype="">math.Pow(x0,2.0)</function>
    <function idx="77" symbol="X3" terminals="1" uniontype="">math.Pow(x0,3.0)</function>
    <function idx="78" symbol="X4" terminals="1" uniontype="">math.Pow(x0,4.0)</function>
    <function idx="79" symbol="X5" terminals="1" uniontype="">math.Pow(x0,5.0)</function>
    <function idx="80" symbol="3Rt" terminals="1" uniontype="">gep3Rt(x0)</function>
    <function idx="81" symbol="4Rt" terminals="1" uniontype="">math.Pow(x0,(1.0/4.0))</function>
    <function idx="82" symbol="5Rt" terminals="1" uniontype="">gep5Rt(x0)</function>
    <function idx="84" symbol="Add3" terminals="3" uniontype="">(x0+x1+x2)</function>
    <function idx="86" symbol="Sub3" terminals="3" uniontype="">(x0-x1-x2)</function>
    <function idx="88" symbol="Mul3" terminals="3" uniontype="">(x0*x1*x2)</function>
    <function idx="90" symbol="Div3" terminals="3" uniontype="">(x0/x1/x2)</function>
    <function idx="85" symbol="Add4" terminals="4" uniontype="">(x0+x1+x2+x3)</function>
    <function idx="87" symbol="Sub4" terminals="4" uniontype="">(x0-x1-x2-x3)</function>
    <function idx="89" symbol="Mul4" terminals="4" uniontype="">(x0*x1*x2*x3)</function>
    <function idx="91" symbol="Div4" terminals="4" uniontype="">(x0/x1/x2/x3)</function>
    <function idx="92" symbol="Min2" terminals="2" uniontype="{tempvarname} = math.Min({tempvarname},{member})">math.Min(x0,x1)</function>
    <function idx="93" symbol="Min3" terminals="3" uniontype="">gepMin3(x0,x1,x2)</function>
    <function idx="94" symbol="Min4" terminals="4" uniontype="">gepMin4(x0,x1,x2,x3)</function>
    <function idx="95" symbol="Max2" terminals="2" uniontype="{tempvarname} = math.Ma{CHARX}({tempvarname},{member})">math.Max(x0,x1)</function>
    <function idx="96" symbol="Max3" terminals="3" uniontype="">gepMax3(x0,x1,x2)</function>
    <function idx="97" symbol="Max4" terminals="4" uniontype="">gepMax4(x0,x1,x2,x3)</function>
    <function idx="98" symbol="Avg2" terminals="2" uniontype="{tempvarname} = ({tempvarname} + {member}) / 2.0">((x0+x1)/2.0)</function>
    <function idx="99" symbol="Avg3" terminals="3" uniontype="">((x0+x1+x2)/3.0)</function>
    <function idx="100" symbol="Avg4" terminals="4" uniontype="">((x0+x1+x2+x3)/4.0)</function>
    <function idx="11" symbol="Logi" terminals="1" uniontype="">gepLogi(x0)</function>
    <function idx="101" symbol="Logi2" terminals="2" uniontype="">gepLogi2(x0,x1)</function>
    <function idx="102" symbol="Logi3" terminals="3" uniontype="">gepLogi3(x0,x1,x2)</function>
    <function idx="103" symbol="Logi4" terminals="4" uniontype="">gepLogi4(x0,x1,x2,x3)</function>
    <function idx="104" symbol="Gau" terminals="1" uniontype="">gepGau(x0)</function>
    <function idx="105" symbol="Gau2" terminals="2" uniontype="">gepGau2(x0,x1)</function>
    <function idx="106" symbol="Gau3" terminals="3" uniontype="">gepGau3(x0,x1,x2)</function>
    <function idx="107" symbol="Gau4" terminals="4" uniontype="">gepGau4(x0,x1,x2,x3)</function>
    <function idx="70" symbol="Zero" terminals="1" uniontype="">(0.0)</function>
    <function idx="71" symbol="One" terminals="1" uniontype="">(1.0)</function>
    <function idx="72" symbol="Zero2" terminals="2" uniontype="">(0.0)</function>
    <function idx="73" symbol="One2" terminals="2" uniontype="">(1.0)</function>
    <function idx="74" symbol="Pi" terminals="1" uniontype="">(math.Pi)</function>
    <function idx="75" symbol="E" terminals="1" uniontype="">(math.E)</function>
    <function idx="18" symbol="Sin" terminals="1" uniontype="">math.Sin(x0)</function>
    <function idx="19" symbol="Cos" terminals="1" uniontype="">math.Cos(x0)</function>
    <function idx="20" symbol="Tan" terminals="1" uniontype="">math.Tan(x0)</function>
    <function idx="21" symbol="Csc" terminals="1" uniontype="">(1.0/math.Sin(x0))</function>
    <function idx="22" symbol="Sec" terminals="1" uniontype="">(1.0/math.Cos(x0))</function>
    <function idx="23" symbol="Cot" terminals="1" uniontype="">(1.0/math.Tan(x0))</function>
    <function idx="24" symbol="Asin" terminals="1" uniontype="">math.Asin(x0)</function>
    <function idx="25" symbol="Acos" terminals="1" uniontype="">math.Acos(x0)</function>
    <function idx="26" symbol="Atan" terminals="1" uniontype="">math.Atan(x0)</function>
    <function idx="27" symbol="Acsc" terminals="1" uniontype="">gepAcsc(x0)</function>
    <function idx="28" symbol="Asec" terminals="1" uniontype="">gepAsec(x0)</function>
    <function idx="29" symbol="Acot" terminals="1" uniontype="">gepAcot(x0)</function>
    <function idx="30" symbol="Sinh" terminals="1" uniontype="">math.Sinh(x0)</function>
    <function idx="31" symbol="Cosh" terminals="1" uniontype="">math.Cosh(x0)</function>
    <function idx="32" symbol="Tanh" terminals="1" uniontype="">math.Tanh(x0)</function>
    <function idx="33" symbol="Csch" terminals="1" uniontype="">(1.0/math.Sinh(x0))</function>
    <function idx="34" symbol="Sech" terminals="1" uniontype="">(1.0/math.Cosh(x0))</function>
    <function idx="35" symbol="Coth" terminals="1" uniontype="">(1.0/math.Tanh(x0))</function>
    <function idx="36" symbol="Asinh" terminals="1" uniontype="">math.Asinh(x0)</function>
    <function idx="37" symbol="Acosh" terminals="1" uniontype="">math.Acosh(x0)</function>
    <function idx="38" symbol="Atanh" terminals="1" uniontype="">math.Atanh(x0)</function>
    <function idx="39" symbol="Acsch" terminals="1" uniontype="">gepAcsch(x0)</function>
    <function idx="40" symbol="Asech" terminals="1" uniontype="">gepAsech(x0)</function>
    <function idx="41" symbol="Acoth" terminals="1" uniontype="">gepAcoth(x0)</function>
    <function idx="108" symbol="NOT" terminals="1" uniontype="">(1.0-x0)</function>
    <function idx="279" symbol="Ramp1" terminals="1" uniontype="">gepRamp1(x0)</function>
    <function idx="280" symbol="Ramp2" terminals="1" uniontype="">gepRamp2(x0)</function>
    <function idx="281" symbol="Ramp3" terminals="1" uniontype="">gepRamp3(x0)</function>
    <function idx="282" symbol="Ramp4" terminals="1" uniontype="">gepRamp4(x0)</function>
    <function idx="283" symbol="Step1" terminals="1" uniontype="">gepStep1(x0)</function>
    <function idx="284" symbol="Step2" terminals="1" uniontype="">gepStep2(x0)</function>
    <function idx="285" symbol="Step3" terminals="1" uniontype="">gepStep3(x0)</function>
    <function idx="286" symbol="Step4" terminals="1" uniontype="">gepStep4(x0)</function>
    <function idx="287" symbol="CL2A" terminals="2" uniontype="{tempvarname} = gepCL2A({tempvarname},{member})">gepCL2A(x0,x1)</function>
    <function idx="288" symbol="CL2B" terminals="2" uniontype="">gepCL2B(x0,x1)</function>
    <function idx="289" symbol="CL2C" terminals="2" uniontype="">gepCL2C(x0,x1)</function>
    <function idx="290" symbol="CL2D" terminals="2" uniontype="{tempvarname} = gepCL2D({tempvarname},{member})">gepCL2D(x0,x1)</function>
    <function idx="291" symbol="CL2E" terminals="2" uniontype="">gepCL2E(x0,x1)</function>
    <function idx="292" symbol="CL2F" terminals="2" uniontype="">gepCL2F(x0,x1)</function>
    <function idx="293" symbol="CL3A" terminals="2" uniontype="{tempvarname} = gepCL3A({tempvarname},{member})">gepCL3A(x0,x1)</function>
    <function idx="294" symbol="CL3B" terminals="2" uniontype="{tempvarname} = gepCL3B({tempvarname},{member})">gepCL3B(x0,x1)</function>
    <function idx="295" symbol="CL3C" terminals="2" uniontype="{tempvarname} = gepCL3C({tempvarname},{member})">gepCL3C(x0,x1)</function>
    <function idx="296" symbol="Map3A" terminals="2" uniontype="">gepMap3A(x0,x1)</function>
    <function idx="297" symbol="Map3B" terminals="3" uniontype="">gepMap3B(x0,x1,x2)</function>
    <function idx="298" symbol="Map3C" terminals="4" uniontype="">gepMap3C(x0,x1,x2,x3)</function>
    <function idx="299" symbol="Map4A" terminals="2" uniontype="">gepMap4A(x0,x1)</function>
    <function idx="300" symbol="Map4B" terminals="3" uniontype="">gepMap4B(x0,x1,x2)</function>
    <function idx="301" symbol="Map4C" terminals="4" uniontype="">gepMap4C(x0,x1,x2,x3)</function>
    <function idx="302" symbol="Map5A" terminals="2" uniontype="">gepMap5A(x0,x1)</function>
    <function idx="303" symbol="Map5B" terminals="3" uniontype="">gepMap5B(x0,x1,x2)</function>
    <function idx="304" symbol="Map5C" terminals="4" uniontype="">gepMap5C(x0,x1,x2,x3)</function>
    <function idx="305" symbol="Map6A" terminals="2" uniontype="">gepMap6A(x0,x1)</function>
    <function idx="306" symbol="Map6B" terminals="3" uniontype="">gepMap6B(x0,x1,x2)</function>
    <function idx="307" symbol="Map6C" terminals="4" uniontype="">gepMap6C(x0,x1,x2,x3)</function>
    <function idx="308" symbol="ECL3A" terminals="3" uniontype="">gepECL3A(x0,x1,x2)</function>
    <function idx="309" symbol="ECL3B" terminals="3" uniontype="">gepECL3B(x0,x1,x2)</function>
    <function idx="310" symbol="ECL3C" terminals="3" uniontype="">gepECL3C(x0,x1,x2)</function>
    <function idx="311" symbol="ECL3D" terminals="4" uniontype="">gepECL3D(x0,x1,x2,x3)</function>
    <function idx="312" symbol="AMin2" terminals="2" uniontype="{tempvarname} = gepAMin2({tempvarname},{member})">gepAMin2(x0,x1)</function>
    <function idx="313" symbol="AMin3" terminals="3" uniontype="">gepAMin3(x0,x1,x2)</function>
    <function idx="314" symbol="AMin4" terminals="4" uniontype="">gepAMin4(x0,x1,x2,x3)</function>
    <function idx="315" symbol="AMax2" terminals="2" uniontype="">gepAMax2(x0,x1)</function>
    <function idx="316" symbol="AMax3" terminals="3" uniontype="">gepAMax3(x0,x1,x2)</function>
    <function idx="317" symbol="AMax4" terminals="4" uniontype="">gepAMax4(x0,x1,x2,x3)</function>
    <function idx="42" symbol="OR1" terminals="2" uniontype="">gepOR1(x0,x1)</function>
    <function idx="43" symbol="OR2" terminals="2" uniontype="">gepOR2(x0,x1)</function>
    <function idx="109" symbol="OR3" terminals="2" uniontype="">gepOR3(x0,x1)</function>
    <function idx="110" symbol="OR4" terminals="2" uniontype="">gepOR4(x0,x1)</function>
    <function idx="111" symbol="OR5" terminals="2" uniontype="">gepOR5(x0,x1)</function>
    <function idx="112" symbol="OR6" terminals="2" uniontype="">gepOR6(x0,x1)</function>
    <function idx="44" symbol="AND1" terminals="2" uniontype="">gepAND1(x0,x1)</function>
    <function idx="45" symbol="AND2" terminals="2" uniontype="">gepAND2(x0,x1)</function>
    <function idx="113" symbol="AND3" terminals="2" uniontype="">gepAND3(x0,x1)</function>
    <function idx="114" symbol="AND4" terminals="2" uniontype="">gepAND4(x0,x1)</function>
    <function idx="115" symbol="AND5" terminals="2" uniontype="">gepAND5(x0,x1)</function>
    <function idx="116" symbol="AND6" terminals="2" uniontype="">gepAND6(x0,x1)</function>
    <function idx="46" symbol="LT2A" terminals="2" uniontype="">gepLT2A(x0,x1)</function>
    <function idx="47" symbol="GT2A" terminals="2" uniontype="">gepGT2A(x0,x1)</function>
    <function idx="48" symbol="LOE2A" terminals="2" uniontype="">gepLOE2A(x0,x1)</function>
    <function idx="49" symbol="GOE2A" terminals="2" uniontype="">gepGOE2A(x0,x1)</function>
    <function idx="50" symbol="ET2A" terminals="2" uniontype="">gepET2A(x0,x1)</function>
    <function idx="51" symbol="NET2A" terminals="2" uniontype="">gepNET2A(x0,x1)</function>
    <function idx="52" symbol="LT2B" terminals="2" uniontype="">gepLT2B(x0,x1)</function>
    <function idx="53" symbol="GT2B" terminals="2" uniontype="">gepGT2B(x0,x1)</function>
    <function idx="54" symbol="LOE2B" terminals="2" uniontype="">gepLOE2B(x0,x1)</function>
    <function idx="55" symbol="GOE2B" terminals="2" uniontype="">gepGOE2B(x0,x1)</function>
    <function idx="56" symbol="ET2B" terminals="2" uniontype="">gepET2B(x0,x1)</function>
    <function idx="57" symbol="NET2B" terminals="2" uniontype="">gepNET2B(x0,x1)</function>
    <function idx="117" symbol="LT2C" terminals="2" uniontype="">gepLT2C(x0,x1)</function>
    <function idx="118" symbol="GT2C" terminals="2" uniontype="">gepGT2C(x0,x1)</function>
    <function idx="119" symbol="LOE2C" terminals="2" uniontype="">gepLOE2C(x0,x1)</function>
    <function idx="120" symbol="GOE2C" terminals="2" uniontype="">gepGOE2C(x0,x1)</function>
    <function idx="121" symbol="ET2C" terminals="2" uniontype="">gepET2C(x0,x1)</function>
    <function idx="122" symbol="NET2C" terminals="2" uniontype="">gepNET2C(x0,x1)</function>
    <function idx="123" symbol="LT2D" terminals="2" uniontype="">gepLT2D(x0,x1)</function>
    <function idx="124" symbol="GT2D" terminals="2" uniontype="">gepGT2D(x0,x1)</function>
    <function idx="125" symbol="LOE2D" terminals="2" uniontype="">gepLOE2D(x0,x1)</function>
    <function idx="126" symbol="GOE2D" terminals="2" uniontype="">gepGOE2D(x0,x1)</function>
    <function idx="127" symbol="ET2D" terminals="2" uniontype="">gepET2D(x0,x1)</function>
    <function idx="128" symbol="NET2D" terminals="2" uniontype="">gepNET2D(x0,x1)</function>
    <function idx="129" symbol="LT2E" terminals="2" uniontype="">gepLT2E(x0,x1)</function>
    <function idx="130" symbol="GT2E" terminals="2" uniontype="">gepGT2E(x0,x1)</function>
    <function idx="131" symbol="LOE2E" terminals="2" uniontype="">gepLOE2E(x0,x1)</function>
    <function idx="132" symbol="GOE2E" terminals="2" uniontype="">gepGOE2E(x0,x1)</function>
    <function idx="133" symbol="ET2E" terminals="2" uniontype="">gepET2E(x0,x1)</function>
    <function idx="134" symbol="NET2E" terminals="2" uniontype="">gepNET2E(x0,x1)</function>
    <function idx="135" symbol="LT2F" terminals="2" uniontype="">gepLT2F(x0,x1)</function>
    <function idx="136" symbol="GT2F" terminals="2" uniontype="">gepGT2F(x0,x1)</function>
    <function idx="137" symbol="LOE2F" terminals="2" uniontype="">gepLOE2F(x0,x1)</function>
    <function idx="138" symbol="GOE2F" terminals="2" uniontype="">gepGOE2F(x0,x1)</function>
    <function idx="139" symbol="ET2F" terminals="2" uniontype="">gepET2F(x0,x1)</function>
    <function idx="140" symbol="NET2F" terminals="2" uniontype="">gepNET2F(x0,x1)</function>
    <function idx="141" symbol="LT2G" terminals="2" uniontype="">gepLT2G(x0,x1)</function>
    <function idx="142" symbol="GT2G" terminals="2" uniontype="">gepGT2G(x0,x1)</function>
    <function idx="143" symbol="LOE2G" terminals="2" uniontype="">gepLOE2G(x0,x1)</function>
    <function idx="144" symbol="GOE2G" terminals="2" uniontype="">gepGOE2G(x0,x1)</function>
    <function idx="145" symbol="ET2G" terminals="2" uniontype="">gepET2G(x0,x1)</function>
    <function idx="146" symbol="NET2G" terminals="2" uniontype="">gepNET2G(x0,x1)</function>
    <function idx="58" symbol="LT3A" terminals="3" uniontype="">gepLT3A(x0,x1,x2)</function>
    <function idx="59" symbol="GT3A" terminals="3" uniontype="">gepGT3A(x0,x1,x2)</function>
    <function idx="60" symbol="LOE3A" terminals="3" uniontype="">gepLOE3A(x0,x1,x2)</function>
    <function idx="61" symbol="GOE3A" terminals="3" uniontype="">gepGOE3A(x0,x1,x2)</function>
    <function idx="62" symbol="ET3A" terminals="3" uniontype="">gepET3A(x0,x1,x2)</function>
    <function idx="63" symbol="NET3A" terminals="3" uniontype="">gepNET3A(x0,x1,x2)</function>
    <function idx="147" symbol="LT3B" terminals="3" uniontype="">gepLT3B(x0,x1,x2)</function>
    <function idx="148" symbol="GT3B" terminals="3" uniontype="">gepGT3B(x0,x1,x2)</function>
    <function idx="149" symbol="LOE3B" terminals="3" uniontype="">gepLOE3B(x0,x1,x2)</function>
    <function idx="150" symbol="GOE3B" terminals="3" uniontype="">gepGOE3B(x0,x1,x2)</function>
    <function idx="151" symbol="ET3B" terminals="3" uniontype="">gepET3B(x0,x1,x2)</function>
    <function idx="152" symbol="NET3B" terminals="3" uniontype="">gepNET3B(x0,x1,x2)</function>
    <function idx="153" symbol="LT3C" terminals="3" uniontype="">gepLT3C(x0,x1,x2)</function>
    <function idx="154" symbol="GT3C" terminals="3" uniontype="">gepGT3C(x0,x1,x2)</function>
    <function idx="155" symbol="LOE3C" terminals="3" uniontype="">gepLOE3C(x0,x1,x2)</function>
    <function idx="156" symbol="GOE3C" terminals="3" uniontype="">gepGOE3C(x0,x1,x2)</function>
    <function idx="157" symbol="ET3C" terminals="3" uniontype="">gepET3C(x0,x1,x2)</function>
    <function idx="158" symbol="NET3C" terminals="3" uniontype="">gepNET3C(x0,x1,x2)</function>
    <function idx="159" symbol="LT3D" terminals="3" uniontype="">gepLT3D(x0,x1,x2)</function>
    <function idx="160" symbol="GT3D" terminals="3" uniontype="">gepGT3D(x0,x1,x2)</function>
    <function idx="161" symbol="LOE3D" terminals="3" uniontype="">gepLOE3D(x0,x1,x2)</function>
    <function idx="162" symbol="GOE3D" terminals="3" uniontype="">gepGOE3D(x0,x1,x2)</function>
    <function idx="163" symbol="ET3D" terminals="3" uniontype="">gepET3D(x0,x1,x2)</function>
    <function idx="164" symbol="NET3D" terminals="3" uniontype="">gepNET3D(x0,x1,x2)</function>
    <function idx="165" symbol="LT3E" terminals="3" uniontype="">gepLT3E(x0,x1,x2)</function>
    <function idx="166" symbol="GT3E" terminals="3" uniontype="">gepGT3E(x0,x1,x2)</function>
    <function idx="167" symbol="LOE3E" terminals="3" uniontype="">gepLOE3E(x0,x1,x2)</function>
    <function idx="168" symbol="GOE3E" terminals="3" uniontype="">gepGOE3E(x0,x1,x2)</function>
    <function idx="169" symbol="ET3E" terminals="3" uniontype="">gepET3E(x0,x1,x2)</function>
    <function idx="170" symbol="NET3E" terminals="3" uniontype="">gepNET3E(x0,x1,x2)</function>
    <function idx="171" symbol="LT3F" terminals="3" uniontype="">gepLT3F(x0,x1,x2)</function>
    <function idx="172" symbol="GT3F" terminals="3" uniontype="">gepGT3F(x0,x1,x2)</function>
    <function idx="173" symbol="LOE3F" terminals="3" uniontype="">gepLOE3F(x0,x1,x2)</function>
    <function idx="174" symbol="GOE3F" terminals="3" uniontype="">gepGOE3F(x0,x1,x2)</function>
    <function idx="175" symbol="ET3F" terminals="3" uniontype="">gepET3F(x0,x1,x2)</function>
    <function idx="176" symbol="NET3F" terminals="3" uniontype="">gepNET3F(x0,x1,x2)</function>
    <function idx="177" symbol="LT3G" terminals="3" uniontype="">gepLT3G(x0,x1,x2)</function>
    <function idx="178" symbol="GT3G" terminals="3" uniontype="">gepGT3G(x0,x1,x2)</function>
    <function idx="179" symbol="LOE3G" terminals="3" uniontype="">gepLOE3G(x0,x1,x2)</function>
    <function idx="180" symbol="GOE3G" terminals="3" uniontype="">gepGOE3G(x0,x1,x2)</function>
    <function idx="181" symbol="ET3G" terminals="3" uniontype="">gepET3G(x0,x1,x2)</function>
    <function idx="182" symbol="NET3G" terminals="3" uniontype="">gepNET3G(x0,x1,x2)</function>
    <function idx="183" symbol="LT3H" terminals="3" uniontype="">gepLT3H(x0,x1,x2)</function>
    <function idx="184" symbol="GT3H" terminals="3" uniontype="">gepGT3H(x0,x1,x2)</function>
    <function idx="185" symbol="LOE3H" terminals="3" uniontype="">gepLOE3H(x0,x1,x2)</function>
    <function idx="186" symbol="GOE3H" terminals="3" uniontype="">gepGOE3H(x0,x1,x2)</function>
    <function idx="187" symbol="ET3H" terminals="3" uniontype="">gepET3H(x0,x1,x2)</function>
    <function idx="188" symbol="NET3H" terminals="3" uniontype="">gepNET3H(x0,x1,x2)</function>
    <function idx="189" symbol="LT3I" terminals="3" uniontype="">gepLT3I(x0,x1,x2)</function>
    <function idx="190" symbol="GT3I" terminals="3" uniontype="">gepGT3I(x0,x1,x2)</function>
    <function idx="191" symbol="LOE3I" terminals="3" uniontype="">gepLOE3I(x0,x1,x2)</function>
    <function idx="192" symbol="GOE3I" terminals="3" uniontype="">gepGOE3I(x0,x1,x2)</function>
    <function idx="193" symbol="ET3I" terminals="3" uniontype="">gepET3I(x0,x1,x2)</function>
    <function idx="194" symbol="NET3I" terminals="3" uniontype="">gepNET3I(x0,x1,x2)</function>
    <function idx="195" symbol="LT3J" terminals="3" uniontype="">gepLT3J(x0,x1,x2)</function>
    <function idx="196" symbol="GT3J" terminals="3" uniontype="">gepGT3J(x0,x1,x2)</function>
    <function idx="197" symbol="LOE3J" terminals="3" uniontype="">gepLOE3J(x0,x1,x2)</function>
    <function idx="198" symbol="GOE3J" terminals="3" uniontype="">gepGOE3J(x0,x1,x2)</function>
    <function idx="199" symbol="ET3J" terminals="3" uniontype="">gepET3J(x0,x1,x2)</function>
    <function idx="200" symbol="NET3J" terminals="3" uniontype="">gepNET3J(x0,x1,x2)</function>
    <function idx="201" symbol="LT3K" terminals="3" uniontype="">gepLT3K(x0,x1,x2)</function>
    <function idx="202" symbol="GT3K" terminals="3" uniontype="">gepGT3K(x0,x1,x2)</function>
    <function idx="203" symbol="LOE3K" terminals="3" uniontype="">gepLOE3K(x0,x1,x2)</function>
    <function idx="204" symbol="GOE3K" terminals="3" uniontype="">gepGOE3K(x0,x1,x2)</function>
    <function idx="205" symbol="ET3K" terminals="3" uniontype="">gepET3K(x0,x1,x2)</function>
    <function idx="206" symbol="NET3K" terminals="3" uniontype="">gepNET3K(x0,x1,x2)</function>
    <function idx="207" symbol="LT3L" terminals="3" uniontype="">gepLT3L(x0,x1,x2)</function>
    <function idx="208" symbol="GT3L" terminals="3" uniontype="">gepGT3L(x0,x1,x2)</function>
    <function idx="209" symbol="LOE3L" terminals="3" uniontype="">gepLOE3L(x0,x1,x2)</function>
    <function idx="210" symbol="GOE3L" terminals="3" uniontype="">gepGOE3L(x0,x1,x2)</function>
    <function idx="211" symbol="ET3L" terminals="3" uniontype="">gepET3L(x0,x1,x2)</function>
    <function idx="212" symbol="NET3L" terminals="3" uniontype="">gepNET3L(x0,x1,x2)</function>
    <function idx="64" symbol="LT4A" terminals="4" uniontype="">gepLT4A(x0,x1,x2,x3)</function>
    <function idx="65" symbol="GT4A" terminals="4" uniontype="">gepGT4A(x0,x1,x2,x3)</function>
    <function idx="66" symbol="LOE4A" terminals="4" uniontype="">gepLOE4A(x0,x1,x2,x3)</function>
    <function idx="67" symbol="GOE4A" terminals="4" uniontype="">gepGOE4A(x0,x1,x2,x3)</function>
    <function idx="68" symbol="ET4A" terminals="4" uniontype="">gepET4A(x0,x1,x2,x3)</function>
    <function idx="69" symbol="NET4A" terminals="4" uniontype="">gepNET4A(x0,x1,x2,x3)</function>
    <function idx="213" symbol="LT4B" terminals="4" uniontype="">gepLT4B(x0,x1,x2,x3)</function>
    <function idx="214" symbol="GT4B" terminals="4" uniontype="">gepGT4B(x0,x1,x2,x3)</function>
    <function idx="215" symbol="LOE4B" terminals="4" uniontype="">gepLOE4B(x0,x1,x2,x3)</function>
    <function idx="216" symbol="GOE4B" terminals="4" uniontype="">gepGOE4B(x0,x1,x2,x3)</function>
    <function idx="217" symbol="ET4B" terminals="4" uniontype="">gepET4B(x0,x1,x2,x3)</function>
    <function idx="218" symbol="NET4B" terminals="4" uniontype="">gepNET4B(x0,x1,x2,x3)</function>
    <function idx="219" symbol="LT4C" terminals="4" uniontype="">gepLT4C(x0,x1,x2,x3)</function>
    <function idx="220" symbol="GT4C" terminals="4" uniontype="">gepGT4C(x0,x1,x2,x3)</function>
    <function idx="221" symbol="LOE4C" terminals="4" uniontype="">gepLOE4C(x0,x1,x2,x3)</function>
    <function idx="222" symbol="GOE4C" terminals="4" uniontype="">gepGOE4C(x0,x1,x2,x3)</function>
    <function idx="223" symbol="ET4C" terminals="4" uniontype="">gepET4C(x0,x1,x2,x3)</function>
    <function idx="224" symbol="NET4C" terminals="4" uniontype="">gepNET4C(x0,x1,x2,x3)</function>
    <function idx="225" symbol="LT4D" terminals="4" uniontype="">gepLT4D(x0,x1,x2,x3)</function>
    <function idx="226" symbol="GT4D" terminals="4" uniontype="">gepGT4D(x0,x1,x2,x3)</function>
    <function idx="227" symbol="LOE4D" terminals="4" uniontype="">gepLOE4D(x0,x1,x2,x3)</function>
    <function idx="228" symbol="GOE4D" terminals="4" uniontype="">gepGOE4D(x0,x1,x2,x3)</function>
    <function idx="229" symbol="ET4D" terminals="4" uniontype="">gepET4D(x0,x1,x2,x3)</function>
    <function idx="230" symbol="NET4D" terminals="4" uniontype="">gepNET4D(x0,x1,x2,x3)</function>
    <function idx="231" symbol="LT4E" terminals="4" uniontype="">gepLT4E(x0,x1,x2,x3)</function>
    <function idx="232" symbol="GT4E" terminals="4" uniontype="">gepGT4E(x0,x1,x2,x3)</function>
    <function idx="233" symbol="LOE4E" terminals="4" uniontype="">gepLOE4E(x0,x1,x2,x3)</function>
    <function idx="234" symbol="GOE4E" terminals="4" uniontype="">gepGOE4E(x0,x1,x2,x3)</function>
    <function idx="235" symbol="ET4E" terminals="4" uniontype="">gepET4E(x0,x1,x2,x3)</function>
    <function idx="236" symbol="NET4E" terminals="4" uniontype="">gepNET4E(x0,x1,x2,x3)</function>
    <function idx="237" symbol="LT4F" terminals="4" uniontype="">gepLT4F(x0,x1,x2,x3)</function>
    <function idx="238" symbol="GT4F" terminals="4" uniontype="">gepGT4F(x0,x1,x2,x3)</function>
    <function idx="239" symbol="LOE4F" terminals="4" uniontype="">gepLOE4F(x0,x1,x2,x3)</function>
    <function idx="240" symbol="GOE4F" terminals="4" uniontype="">gepGOE4F(x0,x1,x2,x3)</function>
    <function idx="241" symbol="ET4F" terminals="4" uniontype="">gepET4F(x0,x1,x2,x3)</function>
    <function idx="242" symbol="NET4F" terminals="4" uniontype="">gepNET4F(x0,x1,x2,x3)</function>
    <function idx="243" symbol="LT4G" terminals="4" uniontype="">gepLT4G(x0,x1,x2,x3)</function>
    <function idx="244" symbol="GT4G" terminals="4" uniontype="">gepGT4G(x0,x1,x2,x3)</function>
    <function idx="245" symbol="LOE4G" terminals="4" uniontype="">gepLOE4G(x0,x1,x2,x3)</function>
    <function idx="246" symbol="GOE4G" terminals="4" uniontype="">gepGOE4G(x0,x1,x2,x3)</function>
    <function idx="247" symbol="ET4G" terminals="4" uniontype="">gepET4G(x0,x1,x2,x3)</function>
    <function idx="248" symbol="NET4G" terminals="4" uniontype="">gepNET4G(x0,x1,x2,x3)</function>
    <function idx="249" symbol="LT4H" terminals="4" uniontype="">gepLT4H(x0,x1,x2,x3)</function>
    <function idx="250" symbol="GT4H" terminals="4" uniontype="">gepGT4H(x0,x1,x2,x3)</function>
    <function idx="251" symbol="LOE4H" terminals="4" uniontype="">gepLOE4H(x0,x1,x2,x3)</function>
    <function idx="252" symbol="GOE4H" terminals="4" uniontype="">gepGOE4H(x0,x1,x2,x3)</function>
    <function idx="253" symbol="ET4H" terminals="4" uniontype="">gepET4H(x0,x1,x2,x3)</function>
    <function idx="254" symbol="NET4H" terminals="4" uniontype="">gepNET4H(x0,x1,x2,x3)</function>
    <function idx="255" symbol="LT4I" terminals="4" uniontype="">gepLT4I(x0,x1,x2,x3)</function>
    <function idx="256" symbol="GT4I" terminals="4" uniontype="">gepGT4I(x0,x1,x2,x3)</function>
    <function idx="257" symbol="LOE4I" terminals="4" uniontype="">gepLOE4I(x0,x1,x2,x3)</function>
    <function idx="258" symbol="GOE4I" terminals="4" uniontype="">gepGOE4I(x0,x1,x2,x3)</function>
    <function idx="259" symbol="ET4I" terminals="4" uniontype="">gepET4I(x0,x1,x2,x3)</function>
    <function idx="260" symbol="NET4I" terminals="4" uniontype="">gepNET4I(x0,x1,x2,x3)</function>
    <function idx="261" symbol="LT4J" terminals="4" uniontype="">gepLT4J(x0,x1,x2,x3)</function>
    <function idx="262" symbol="GT4J" terminals="4" uniontype="">gepGT4J(x0,x1,x2,x3)</function>
    <function idx="263" symbol="LOE4J" terminals="4" uniontype="">gepLOE4J(x0,x1,x2,x3)</function>
    <function idx="264" symbol="GOE4J" terminals="4" uniontype="">gepGOE4J(x0,x1,x2,x3)</function>
    <function idx="265" symbol="ET4J" terminals="4" uniontype="">gepET4J(x0,x1,x2,x3)</function>
    <function idx="266" symbol="NET4J" terminals="4" uniontype="">gepNET4J(x0,x1,x2,x3)</function>
    <function idx="267" symbol="LT4K" terminals="4" uniontype="">gepLT4K(x0,x1,x2,x3)</function>
    <function idx="268" symbol="GT4K" terminals="4" uniontype="">gepGT4K(x0,x1,x2,x3)</function>
    <function idx="269" symbol="LOE4K" terminals="4" uniontype="">gepLOE4K(x0,x1,x2,x3)</function>
    <function idx="270" symbol="GOE4K" terminals="4" uniontype="">gepGOE4K(x0,x1,x2,x3)</function>
    <function idx="271" symbol="ET4K" terminals="4" uniontype="">gepET4K(x0,x1,x2,x3)</function>
    <function idx="272" symbol="NET4K" terminals="4" uniontype="">gepNET4K(x0,x1,x2,x3)</function>
    <function idx="273" symbol="LT4L" terminals="4" uniontype="">gepLT4L(x0,x1,x2,x3)</function>
    <function idx="274" symbol="GT4L" terminals="4" uniontype="">gepGT4L(x0,x1,x2,x3)</function>
    <function idx="275" symbol="LOE4L" terminals="4" uniontype="">gepLOE4L(x0,x1,x2,x3)</function>
    <function idx="276" symbol="GOE4L" terminals="4" uniontype="">gepGOE4L(x0,x1,x2,x3)</function>
    <function idx="277" symbol="ET4L" terminals="4" uniontype="">gepET4L(x0,x1,x2,x3)</function>
    <function idx="278" symbol="NET4L" terminals="4" uniontype="">gepNET4L(x0,x1,x2,x3)</function>
  </functions>
  <!-- Code Structure -->
  <order>
    <item name="ModelComments" />
    <item name="Open" />
    <item name="HelpersDeclaration" />
    <item name="Subheader" />
    <item name="Header" />
    <item name="RandomConstants" />
    <item name="Constants" />
    <item name="CallTransform" />
    <item name="DataTransformationCall" />
    <item name="HelpersAssignment" />
    <item name="TemporaryVariable" />
    <item name="Body" />
    <item name="DataReverseTransformationCall" />
    <item name="Footer" />
    <item name="Helpers" />
    <item name="LinkingHelpers" />
    <item name="DDF" />
    <item name="UDF" />
    <item name="TransformHelper" />
    <item name="DataTransformationHelper" />
    <item name="DataReverseTransformationHelper" />
    <item name="Close" />
  </order>
  <!-- Opening and Closing Statements -->
  <open>
    package gepModel{CRLF}{CRLF}
  </open>
  <close> </close>
  <!-- The default header is applied to all non specified cases. {SUPPRESS_CRLF}-->
  <headers>
    <header type="default" replace="no">import ({CRLF}{TAB}"math"{CRLF}){CRLF}{CRLF}func gepModel(d []float64) float64 {</header>
    <header type="CL_ProbabilityOne" replace="yes">import ({CRLF}{TAB}"math"{CRLF}){CRLF}{CRLF}func gepModel(d []float64) float64 {{CRLF}{TAB}const MODEL_AVERAGE = {MODEL_AVERAGE}{CRLF}{TAB}const MODEL_STDEV = {MODEL_STDEV}{CRLF}{TAB}const ROUNDING_THRESHOLD = ({set_ff#Threshold} - MODEL_AVERAGE) / MODEL_STDEV{CRLF}</header>
    <header type="CL_MostLikelyClass" replace="yes">import ({CRLF}{TAB}"math"{CRLF}){CRLF}{CRLF}func gepModel(d []float64) int {{CRLF}{TAB}const ROUNDING_THRESHOLD = {set_ff#Threshold}{CRLF}</header>
    <header type="LR_MostLikelyClass" replace="yes">import ({CRLF}{TAB}"math"{CRLF}){CRLF}{CRLF}func gepModel(d []float64) int {{CRLF}{TAB}const ROUNDING_THRESHOLD = {set_ff#Threshold}{CRLF}</header>
    <header type="nominal" replace="no">import ({CRLF}{TAB}"math"{CRLF}{TAB}"strconv"{CRLF}){CRLF}{CRLF}func gepModel(d_string []string) float64 {</header>
    <header type="CL_nominal_RawOutput" replace="yes">import ({CRLF}{TAB}"math"{CRLF}{TAB}"strconv"{CRLF}){CRLF}{CRLF}func gepModel(d_string []string) float64 {</header>
    <header type="CL_nominal_ProbabilityOne" replace="yes">import ({CRLF}{TAB}"math"{CRLF}{TAB}"strconv"{CRLF}){CRLF}{CRLF}func gepModel(d_string []string) float64 {{CRLF}{TAB}const MODEL_AVERAGE = {MODEL_AVERAGE}{CRLF}{TAB}const MODEL_STDEV = {MODEL_STDEV}{CRLF}{TAB}const ROUNDING_THRESHOLD = ({set_ff#Threshold} - MODEL_AVERAGE) / MODEL_STDEV{CRLF}</header>
    <header type="CL_nominal_MostLikelyClass" replace="yes">import ({CRLF}{TAB}"math"{CRLF}{TAB}"strconv"{CRLF}){CRLF}{CRLF}func gepModel(d_string []string) int {{CRLF}{TAB}const ROUNDING_THRESHOLD = {set_ff#Threshold}{CRLF}</header>
    <header type="LR_nominal_RawOutput" replace="yes">import ({CRLF}{TAB}"math"{CRLF}{TAB}"strconv"{CRLF}){CRLF}{CRLF}func gepModel(d_string []string) float64 {</header>
    <header type="LR_nominal_ProbabilityOne" replace="yes">import ({CRLF}{TAB}"math"{CRLF}{TAB}"strconv"{CRLF}){CRLF}{CRLF}func gepModel(d_string []string) float64 {</header>
    <header type="LR_nominal_MostLikelyClass" replace="yes">import ({CRLF}{TAB}"math"{CRLF}{TAB}"strconv"{CRLF}){CRLF}{CRLF}func gepModel(d_string []string) int {{CRLF}{TAB}const ROUNDING_THRESHOLD = {set_ff#Threshold}{CRLF}</header>
  </headers>
  <subheaders>
    <subheader type="default" replace="no">
    </subheader>
    <subheader type="CL_ProbabilityOne" replace="no">
    </subheader>
    <subheader type="CL_MostLikelyClass" replace="no">
    </subheader>
    <subheader type="LR_MostLikelyClass" replace="no">
    </subheader>
    <subheader type="nominal" replace="no">
    </subheader>
    <subheader type="CL_nominal_RawOutput" replace="no">
    </subheader>
    <subheader type="CL_nominal_ProbabilityOne" replace="no">
    </subheader>
    <subheader type="CL_nominal_MostLikelyClass" replace="no">
    </subheader>
    <subheader type="LR_nominal_RawOutput" replace="no">
    </subheader>
    <subheader type="LR_nominal_MostLikelyClass" replace="no">
    </subheader>
  </subheaders>
  <randomconstants>
    <randomconst type="default" replace="no">{TAB}const {labelname} = {labelindex}{CRLF}</randomconst>
  </randomconstants>
  <categories>
    <functioncall call="{TAB}d := make([]float64, {VARIABLE_COUNT}){CRLF}{TAB}TransformCategoricalInputs(d_string, d){CRLF}" />
    <transformfunction header="{CRLF}func atof(a string) float64 {{CRLF}{TAB}if o, err := strconv.ParseFloat(a, 64); err != nil {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return o{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}func TransformCategoricalInputs(input []string, output []float64) {{CRLF}{CRLF}" footer="{CRLF}}" />
    <switch special="ADD_1_TAB_TO_METHOD_BODY" top="switch input[{index}] {{CRLF}" bottom="}{CRLF}{CRLF}" categoricaldefault="default :{CRLF}{TAB}output[{index}] = 0.0{CRLF}" numericaldefault="default :{CRLF}{TAB}output[{index}] = atof(input[{index}]){CRLF}" />
    <case format="case &quot;{nominal}&quot;:{CRLF}{TAB}output[{index}] = {numerical}{CRLF}" />
    <equality format="{CRLF}output[{index}] = atof(input[{index}]){CRLF}{CRLF}" />
  </categories>
  <transformations>
    <transformation name="standardization" call="{TAB}Standardize(d){CRLF}" itemformat="{TAB}const AVERAGE_{index} = {AVERAGE}{CRLF}{TAB}const STDEV_{index} = {STDEV}{CRLF}{TAB}input[{index}] = (input[{index}] - AVERAGE_{index}) / STDEV_{index}{CRLF}{CRLF}" declarations="">{CRLF}func Standardize(input []float64) {{CRLF}{BODY}{CRLF}}{CRLF}</transformation>
    <transformation name="normalization" call="{TAB}Normalize_01(d){CRLF}" itemformat="{TAB}const MIN_{index} = {MIN}{CRLF}{TAB}const MAX_{index} = {MAX}{CRLF}{TAB}input[{index}] = (input[{index}] - MIN_{index}) / (MAX_{index} - MIN_{index}){CRLF}{CRLF}" declarations="">{CRLF}func Normalize_01(input []float64) {{CRLF}{BODY}{CRLF}}{CRLF}</transformation>
    <transformation name="minMaxNormalization" call="{TAB}MinMaxNormalize(d){CRLF}" itemformat="{TAB}const MIN_{index} = {MIN}{CRLF}{TAB}const MAX_{index} = {MAX}{CRLF}{TAB}input[{index}] = (input[{index}] - MIN_{index}) / (MAX_{index} - MIN_{index}) * (NEW_MAX - NEW_MIN) + NEW_MIN{CRLF}{CRLF}" declarations="">{CRLF}func MinMaxNormalize(input []float64) {{CRLF}{TAB}const NEW_MIN = {NEW_MIN}{CRLF}{TAB}const NEW_MAX = {NEW_MAX}{CRLF}{CRLF}{BODY}{CRLF}}{CRLF}</transformation>
  </transformations>
  <reversetransformations>
    <transformation name="standardization" call="{TAB}{tempvarname} = Reverse_Standardization({tempvarname}){CRLF}" itemformat="{TAB}{TAB}// Model standardization{CRLF}{TAB}const MODEL_AVERAGE = {MODEL_AVERAGE}{CRLF}{TAB}const MODEL_STDEV = {MODEL_STDEV}{CRLF}{TAB}modelOutput = (modelOutput - MODEL_AVERAGE) / MODEL_STDEV{CRLF}{CRLF}{TAB}{TAB}// Reverse standardization{TAB}{TAB}{CRLF}{TAB}const TARGET_AVERAGE = {TARGET_AVERAGE}{CRLF}{TAB}const TARGET_STDEV = {TARGET_STDEV}{CRLF}{CRLF}{TAB}return modelOutput * TARGET_STDEV + TARGET_AVERAGE">{CRLF}func Reverse_Standardization(modelOutput float64) float64 {{CRLF}{BODY}{CRLF}}{CRLF}</transformation>
    <transformation name="normalization" call="{TAB}{tempvarname} = Reverse_Normalization_01({tempvarname}){CRLF}" itemformat="{TAB}{TAB}// Model normalization{CRLF}{TAB}const MODEL_MIN = {MODEL_MIN}{CRLF}{TAB}const MODEL_MAX = {MODEL_MAX}{CRLF}{TAB}modelOutput = (modelOutput - MODEL_MIN)/(MODEL_MAX - MODEL_MIN){CRLF}{CRLF}{TAB}{TAB}// Reverse normalization{CRLF}{TAB}const TARGET_MIN = {TARGET_MIN}{CRLF}{TAB}const TARGET_MAX = {TARGET_MAX}{CRLF}{CRLF}{TAB}return modelOutput * (TARGET_MAX - TARGET_MIN) + TARGET_MIN">{CRLF}func Reverse_Normalization_01(modelOutput float64) float64 {{CRLF}{BODY}{CRLF}}{CRLF}</transformation>
    <transformation name="minMaxNormalization" call="{TAB}{tempvarname} = Reverse_MinMaxNormalization({tempvarname}){CRLF}" itemformat="{TAB}const TARGET_MIN = {TARGET_MIN}{CRLF}{TAB}const TARGET_MAX = {TARGET_MAX}{CRLF}{CRLF}{TAB}{TAB}// Model normalization{CRLF}{TAB}const MODEL_MIN = {MODEL_MIN}{CRLF}{TAB}const MODEL_MAX = {MODEL_MAX}{CRLF}{TAB}modelOutput = ((modelOutput - MODEL_MIN)/(MODEL_MAX - MODEL_MIN)) * (NEW_MAX - NEW_MIN) + NEW_MIN{CRLF}{CRLF}{TAB}{TAB}// Reverse normalization{CRLF}{TAB}return ((modelOutput - NEW_MIN) / (NEW_MAX - NEW_MIN)) * (TARGET_MAX - TARGET_MIN) + TARGET_MIN">{CRLF}func Reverse_MinMaxNormalization(modelOutput float64) float64 {{CRLF}{TAB}const NEW_MIN = {NEW_MIN}{CRLF}{TAB}const NEW_MAX = {NEW_MAX}{CRLF}{CRLF}{BODY}{CRLF}}{CRLF}</transformation>
  </reversetransformations>
  <!-- Label constants -->
  <constants>
    <constant type="default" replace="no" labelindex="0">{TAB}const {labelname} = {labelindex}{CRLF}</constant>
  </constants>
  <!-- The default temporary variable name is applied to all non specified cases. -->
  <tempvars>
    <tempvar type="default" typename="float64" varname="y">var y float64</tempvar>
  </tempvars>
  <endline>{CRLF}</endline>
  <!-- Number of TABs to add to each line in the code block -->
  <indent>1</indent>
  <!-- parenstype can be either 0->() or 1->[]. Defines the parentheses used in arrays-->
  <parenstype>1</parenstype>
  <footers>
    <footer type="default" replace="no">return {tempvarname}{CRLF}}</footer>
    <footer type="CL_RawOutput" replace="no">return {tempvarname}{CRLF}}</footer>
    <footer type="CL_ProbabilityOne" replace="no">// Model standardization and shift{CRLF}{TAB}{tempvarname} = ({tempvarname} - MODEL_AVERAGE) / MODEL_STDEV - ROUNDING_THRESHOLD{CRLF}{CRLF}{TAB}// Probability[1] evaluation{CRLF}{TAB}{tempvarname} = 1.0 / (1.0 + math.Exp(-{tempvarname})){CRLF}{CRLF}{TAB}return {tempvarname}{CRLF}}</footer>
    <footer type="CL_MostLikelyClass" replace="no">if {tempvarname} &gt;= ROUNDING_THRESHOLD {{CRLF}{TAB}{TAB}return 1{CRLF}{TAB}}{CRLF}{TAB}return 0{CRLF}}</footer>
    <footer type="LR_RawOutput" replace="no">return {tempvarname}{CRLF}}</footer>
    <footer type="LR_ProbabilityOne" replace="no">const SLOPE = {SLOPE}{CRLF}{TAB}const INTERCEPT = {INTERCEPT}{CRLF}{CRLF}{TAB}probabilityOne := 1.0 / (1.0 + math.Exp(-(SLOPE * {tempvarname} + INTERCEPT))){CRLF}{TAB}return probabilityOne{CRLF}}</footer>
    <footer type="LR_MostLikelyClass" replace="no">if {tempvarname} &gt;= ROUNDING_THRESHOLD {{CRLF}{TAB}{TAB}return 1{CRLF}{TAB}}{CRLF}{TAB}return 0{CRLF}}</footer>
  </footers>
  <helpers count="259" declaration="" assignment="">
    <helper replaces="3Rt">func gep3Rt(x float64) float64 {{CRLF}{TAB}if x &lt; 0.0 {{CRLF}{TAB}{TAB}return -math.Pow(-x, (1.0 / 3.0)){CRLF}{TAB}}{CRLF}{TAB}return math.Pow(x, (1.0 / 3.0)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="5Rt">func gep5Rt(x float64) float64 {{CRLF}{TAB}if x &lt; 0.0 {{CRLF}{TAB}{TAB}return -math.Pow(-x, (1.0 / 5.0)){CRLF}{TAB}}{CRLF}{TAB}return math.Pow(x, (1.0 / 5.0)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Log2">func gepLog2(x, y float64) float64 {{CRLF}{TAB}if y == 0.0 {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}{TAB}return math.Log(x) / math.Log(y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Mod">func gepMod(x, y float64) float64 {{CRLF}{TAB}// The built-in function is incorrect for cases such as -1.0 and 0.2.{CRLF}{TAB}return ((x / y) - float64(int(x/y))) * y{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Logi">func gepLogi(x float64) float64 {{CRLF}{TAB}if math.Abs(x) &gt; 709.0 {{CRLF}{TAB}{TAB}return 1.0 / (1.0 + math.Exp(math.Abs(x) / x * 709.0)){CRLF}{TAB}}{CRLF}{TAB}return 1.0 / (1.0 + math.Exp(-x)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Logi2">func gepLogi2(x, y float64) float64 {{CRLF}{TAB}if math.Abs(x+y) &gt; 709.0 {{CRLF}{TAB}{TAB}return 1.0 / (1.0 + math.Exp(math.Abs(x + y) / (x + y) * 709.0)){CRLF}{TAB}}{CRLF}{TAB}return 1.0 / (1.0 + math.Exp(-(x + y))){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Logi3">func gepLogi3(x, y, z float64) float64 {{CRLF}{TAB}if math.Abs(x+y+z) &gt; 709.0 {{CRLF}{TAB}{TAB}return 1.0 / (1.0 + math.Exp(math.Abs(x + y + z) / (x + y + z) * 709.0)){CRLF}{TAB}}{CRLF}{TAB}return 1.0 / (1.0 + math.Exp(-(x + y + z))){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Logi4">func gepLogi4(a, b, c, d float64) float64 {{CRLF}{TAB}if math.Abs(a+b+c+d) &gt; 709.0 {{CRLF}{TAB}{TAB}return 1.0 / (1.0 + math.Exp(math.Abs(a + b + c + d) / (a + b + c + d) * 709.0)){CRLF}{TAB}}{CRLF}{TAB}return 1.0 / (1.0 + math.Exp(-(a + b + c + d))){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Gau">func gepGau(x float64) float64 {{CRLF}{TAB}return math.Exp(-math.Pow(x, 2.0)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Gau2">func gepGau2(x, y float64) float64 {{CRLF}{TAB}return math.Exp(-math.Pow((x + y), 2.0)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Gau3">func gepGau3(x, y, z float64) float64 {{CRLF}{TAB}return math.Exp(-math.Pow((x + y + z), 2.0)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Gau4">func gepGau4(a, b, c, d float64) float64 {{CRLF}{TAB}return math.Exp(-math.Pow((a + b + c + d), 2.0)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Acsc">func gepAcsc(x float64) float64 {{CRLF}{TAB}var varSign float64{CRLF}{TAB}if x &lt; 0.0 {{CRLF}{TAB}{TAB}varSign = -1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}{TAB}varSign = 1.0{CRLF}{TAB}{TAB}} else {{CRLF}{TAB}{TAB}{TAB}varSign = 0.0{CRLF}{TAB}{TAB}}{CRLF}{TAB}}{CRLF}{TAB}return math.Atan(varSign / math.Sqrt(x*x-1.0)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Asec">func gepAsec(x float64) float64 {{CRLF}{TAB}var varSign float64{CRLF}{TAB}if x &lt; 0.0 {{CRLF}{TAB}{TAB}varSign = -1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}{TAB}varSign = 1.0{CRLF}{TAB}{TAB}} else {{CRLF}{TAB}{TAB}{TAB}varSign = 0.0{CRLF}{TAB}{TAB}}{CRLF}{TAB}}{CRLF}{CRLF}{TAB}if math.Abs(x) == 1.0 {{CRLF}{TAB}{TAB}if x == -1.0 {{CRLF}{TAB}{TAB}{TAB}return 4.0 * math.Atan(1.0){CRLF}{TAB}{TAB}}{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}{TAB}return 2.0*math.Atan(1.0) - math.Atan(varSign/math.Sqrt(x*x-1.0)){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Acot">func gepAcot(x float64) float64 {{CRLF}{TAB}return math.Atan(1.0 / x){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Acsch">func gepAcsch(x float64) float64 {{CRLF}{TAB}var varSign float64{CRLF}{TAB}if x &lt; 0.0 {{CRLF}{TAB}{TAB}varSign = -1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}{TAB}varSign = 1.0{CRLF}{TAB}{TAB}} else {{CRLF}{TAB}{TAB}{TAB}varSign = 0.0{CRLF}{TAB}{TAB}}{CRLF}{TAB}}{CRLF}{TAB}return math.Log((varSign * math.Sqrt(x * x + 1.0) + 1.0) / x){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Asech">func gepAsech(x float64) float64 {{CRLF}{TAB}return math.Log((math.Sqrt(-x * x + 1.0) + 1.0) / x){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Acoth">func gepAcoth(x float64) float64 {{CRLF}{TAB}return math.Log((x + 1.0) / (x - 1.0)) / 2.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Min3">func gepMin3(x, y, z float64) float64 {{CRLF}{TAB}return math.Min(math.Min(x,y),z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Min4">func gepMin4(a, b, c, d float64) float64 {{CRLF}{TAB}return  math.Min(math.Min(math.Min(a,b),c),d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Max3">func gepMax3(x, y, z float64) float64 {{CRLF}{TAB}return math.Max(math.Max(x,y),z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Max4">func gepMax4(a, b, c, d float64) float64 {{CRLF}{TAB}return math.Max(math.Max(math.Max(a,b),c),d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Ramp1">func gepRamp1(x float64) float64 {{CRLF}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}return x{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Ramp2">func gepRamp2(x float64) float64 {{CRLF}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Ramp3">func gepRamp3(x float64) float64 {{CRLF}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return -x{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Ramp4">func gepRamp4(x float64) float64 {{CRLF}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}return -x{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Step1">func gepStep1(x float64) float64 {{CRLF}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Step2">func gepStep2(x float64) float64 {{CRLF}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Step3">func gepStep3(x float64) float64 {{CRLF}{TAB}if x &gt;= 1.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  x &lt;= -1.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Step4">func gepStep4(x float64) float64 {{CRLF}{TAB}if x &gt;= 1.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  x &lt;= 0.0 {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL2A">func gepCL2A(x, y float64) float64 {{CRLF}{TAB}if x &gt; 0.0 &amp;&amp; y &gt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL2B">func gepCL2B(x, y float64) float64 {{CRLF}{TAB}if x &gt;= 0.0 &amp;&amp; y &lt; 0.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL2C">func gepCL2C(x, y float64) float64 {{CRLF}{TAB}if x &gt; 1.0 &amp;&amp; y &lt; -1.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL2D">func gepCL2D(x, y float64) float64 {{CRLF}{TAB}if x &gt; 0.0 &amp;&amp; y &gt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL2E">func gepCL2E(x, y float64) float64 {{CRLF}{TAB}if x &gt;= 0.0 &amp;&amp; y &lt;= 0.0 {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL2F">func gepCL2F(x, y float64) float64 {{CRLF}{TAB}if x &gt; 1.0 &amp;&amp; y &lt; -1.0 {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL3A">func gepCL3A(x, y float64) float64 {{CRLF}{TAB}if x &gt; 0.0 &amp;&amp; y &lt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  x &lt; 0.0 &amp;&amp; y &gt; 0.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL3B">func gepCL3B(x, y float64) float64 {{CRLF}{TAB}if x &gt;= 1.0 &amp;&amp; y &gt;= 1.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  x &lt;= -1.0 &amp;&amp; y &lt;= -1.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="CL3C">func gepCL3C(x, y float64) float64 {{CRLF}{TAB}if x &gt; 0.0 &amp;&amp; y &gt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  x &lt; 0.0 &amp;&amp; y &lt; 0.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map3A">func gepMap3A(x, y float64) float64 {{CRLF}{TAB}const SLACK = 10.0{CRLF}{TAB}if y &lt; (x - SLACK) {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else if  y &gt; (x + SLACK) { {CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map3B">func gepMap3B(x, y, z float64) float64 {{CRLF}{TAB}minValue := math.Min(x,y){CRLF}{TAB}maxValue := math.Max(x,y){CRLF}{TAB}if z &lt; minValue {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else if  z &gt; maxValue {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map3C">func gepMap3C(a, b, c, d float64) float64 {{CRLF}{TAB}minValue := math.Min(math.Min(a,b),c){CRLF}{TAB}maxValue := math.Max(math.Max(a,b),c){CRLF}{TAB}if d &lt; minValue {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else if  d &gt; maxValue {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map4A">func gepMap4A(x, y float64) float64 {{CRLF}{TAB}const SLACK = 10.0{CRLF}{TAB}var outVal float64{CRLF}{TAB}if y &lt; (x - SLACK) { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if y &gt;= (x - SLACK) &amp;&amp; y &lt; x { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if y &gt;= x &amp;&amp; y &lt; (x + SLACK) { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if y &gt;= (x + SLACK) { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map4B">func gepMap4B(x, y, z float64) float64 {{CRLF}{TAB}// evaluate minValue(x,y), maxValue(x,y) and midrange{CRLF}{TAB}minValue := math.Min(x,y){CRLF}{TAB}maxValue := math.Max(x,y){CRLF}{TAB}midrange := (maxValue + minValue)/2.0{CRLF}{TAB}{CRLF}{TAB}var outVal float64{CRLF}{TAB}if z &lt; minValue { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if z &gt;= minValue &amp;&amp; z &lt; midrange { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if z &gt;= midrange &amp;&amp; z &lt; maxValue { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if z &gt;= maxValue { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map4C">func gepMap4C(a, b, c, d float64) float64 {{CRLF}{TAB}// evaluate minValue(a,b,c), maxValue(a,b,c) and midleValue(a,b,c){CRLF}{TAB}// {CRLF}{TAB}// evaluate minValue(a,b,c) and argMin(a,b,c){CRLF}{TAB}minValue := a{CRLF}{TAB}argMin := 0{CRLF}{TAB}if minValue &gt; b {{CRLF}{TAB}{TAB}minValue = b{CRLF}{TAB}{TAB}argMin = 1{CRLF}{TAB}}{CRLF}{TAB}if minValue &gt; c {{CRLF}{TAB}{TAB}minValue = c{CRLF}{TAB}{TAB}argMin = 2{CRLF}{TAB}}{CRLF}{TAB}// evaluate maxValue(a,b,c) and argMax(a,b,c){CRLF}{TAB}maxValue := a{CRLF}{TAB}argMax := 0{CRLF}{TAB}if maxValue &lt; b {{CRLF}{TAB}{TAB}maxValue = b{CRLF}{TAB}{TAB}argMax = 1{CRLF}{TAB}}{CRLF}{TAB}if maxValue &lt; c {{CRLF}{TAB}{TAB}maxValue = c{CRLF}{TAB}{TAB}argMax = 2{CRLF}{TAB}}{CRLF}{TAB}// evaluate midleValue(a,b,c){CRLF}{TAB}midleValue := c{CRLF}{TAB}if 0 != argMin &amp;&amp; 0 != argMax {{CRLF}{TAB}{TAB}midleValue = a{CRLF}{TAB}}{CRLF}{TAB}if 1 != argMin &amp;&amp; 1 != argMax {{CRLF}{TAB}{TAB}midleValue = b{CRLF}{TAB}}{CRLF}{CRLF}{TAB}var outVal float64{CRLF}{TAB}if d &lt; minValue { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if d &gt;= minValue &amp;&amp; d &lt; midleValue { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if d &gt;= midleValue &amp;&amp; d &lt; maxValue { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if d &gt;= maxValue { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map5A">func gepMap5A(x, y float64) float64 {{CRLF}{TAB}const SLACK = 15.0{CRLF}{TAB}var outVal float64{CRLF}{TAB}if y &lt; (x - SLACK) { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if y &gt;= (x - SLACK) &amp;&amp; y &lt; (x - SLACK/3.0) { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if y &gt;= (x - SLACK/3.0) &amp;&amp; y &lt; (x + SLACK/3.0) { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if y &gt;= (x + SLACK/3.0) &amp;&amp; y &lt; (x + SLACK) { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}} else if y &gt;= (x + SLACK) { {CRLF}{TAB}{TAB}outVal = 4.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map5B">func gepMap5B(x, y, z float64) float64 {{CRLF}{TAB}// evaluate minValue(x,y), maxValue(x,y), midpoint1, midpoint2{CRLF}{TAB}minValue := math.Min(x,y){CRLF}{TAB}maxValue := math.Max(x,y){CRLF}{TAB}intervalLength := (maxValue - minValue)/3.0{CRLF}{TAB}midpoint1 := minValue + intervalLength{CRLF}{TAB}midpoint2 := minValue + 2.0*intervalLength{CRLF}{TAB}{CRLF}{TAB}var outVal float64{CRLF}{TAB}if z &lt; minValue { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if z &gt;= minValue &amp;&amp; z &lt; midpoint1 { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if z &gt;= midpoint1 &amp;&amp; z &lt; midpoint2 { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if z &gt;= midpoint2 &amp;&amp; z &lt; maxValue { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}} else if z &gt;= maxValue { {CRLF}{TAB}{TAB}outVal = 4.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map5C">func gepMap5C(a, b, c, d float64) float64 {{CRLF}{TAB}// evaluate minValue(a,b,c), maxValue(a,b,c), midleValue(a,b,c), midrange1, midrange2{CRLF}{TAB}// {CRLF}{TAB}// evaluate minValue(a,b,c) and argMin(a,b,c){CRLF}{TAB}minValue := a{CRLF}{TAB}argMin := 0{CRLF}{TAB}if minValue &gt; b {{CRLF}{TAB}{TAB}minValue = b{CRLF}{TAB}{TAB}argMin = 1{CRLF}{TAB}}{CRLF}{TAB}if minValue &gt; c {{CRLF}{TAB}{TAB}minValue = c{CRLF}{TAB}{TAB}argMin = 2{CRLF}{TAB}}{CRLF}{TAB}// evaluate maxValue(a,b,c) and argMax(a,b,c){CRLF}{TAB}maxValue := a{CRLF}{TAB}argMax := 0{CRLF}{TAB}if maxValue &lt; b {{CRLF}{TAB}{TAB}maxValue = b{CRLF}{TAB}{TAB}argMax = 1{CRLF}{TAB}}{CRLF}{TAB}if maxValue &lt; c {{CRLF}{TAB}{TAB}maxValue = c{CRLF}{TAB}{TAB}argMax = 2{CRLF}{TAB}}{CRLF}{TAB}// evaluate midleValue(a,b,c){CRLF}{TAB}midleValue := c{CRLF}{TAB}if 0 != argMin &amp;&amp; 0 != argMax {{CRLF}{TAB}{TAB}midleValue = a{CRLF}{TAB}}{CRLF}{TAB}if 1 != argMin &amp;&amp; 1 != argMax {{CRLF}{TAB}{TAB}midleValue = b{CRLF}{TAB}}{CRLF}{TAB}midrange1 := (minValue + midleValue)/2.0{CRLF}{TAB}midrange2 := (midleValue + maxValue)/2.0{CRLF}{CRLF}{TAB}var outVal float64{CRLF}{TAB}if d &lt; minValue { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if d &gt;= minValue &amp;&amp; d &lt; midrange1 { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if d &gt;= midrange1 &amp;&amp; d &lt; midrange2 { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if d &gt;= midrange2 &amp;&amp; d &lt; maxValue { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}} else if d &gt;= maxValue { {CRLF}{TAB}{TAB}outVal = 4.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map6A">func gepMap6A(x, y float64) float64 {{CRLF}{TAB}const SLACK = 10.0{CRLF}{TAB}var outVal float64{CRLF}{TAB}if y &lt; (x - SLACK) { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if y &gt;= (x - SLACK) &amp;&amp; y &lt; (x - SLACK/2.0) { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if y &gt;= (x - SLACK/2.0) &amp;&amp; y &lt; x { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if y &gt;= x &amp;&amp; y &lt; (x + SLACK/2.0) { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}} else if y &gt;= (x + SLACK/2.0) &amp;&amp; y &lt; (x + SLACK) { {CRLF}{TAB}{TAB}outVal = 4.0{CRLF}{TAB}} else if y &gt;= (x + SLACK) { {CRLF}{TAB}{TAB}outVal = 5.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map6B">func gepMap6B(x, y, z float64) float64 {{CRLF}{TAB}minValue := math.Min(x,y){CRLF}{TAB}maxValue := math.Max(x,y){CRLF}{TAB}midrange := (minValue + maxValue)/2.0{CRLF}{TAB}midpoint1 := (minValue + midrange)/2.0{CRLF}{TAB}midpoint2 := (midrange + maxValue)/2.0{CRLF}{TAB}{CRLF}{TAB}var outVal float64{CRLF}{TAB}if z &lt; minValue { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if z &gt;= minValue &amp;&amp; z &lt; midpoint1 { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if z &gt;= midpoint1 &amp;&amp; z &lt; midrange { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if z &gt;= midrange &amp;&amp; z &lt; midpoint2 { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}} else if z &gt;= midpoint2 &amp;&amp; z &lt; maxValue { {CRLF}{TAB}{TAB}outVal = 4.0{CRLF}{TAB}} else if z &gt;= maxValue { {CRLF}{TAB}{TAB}outVal = 5.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="Map6C">func gepMap6C(a, b, c, d float64) float64 {{CRLF}{TAB}// evaluate minValue(a,b,c), maxValue(a,b,c), midleValue(a,b,c), midrange1, midrange2{CRLF}{TAB}// {CRLF}{TAB}// evaluate minValue(a,b,c) and argMin(a,b,c){CRLF}{TAB}minValue := a{CRLF}{TAB}argMin := 0{CRLF}{TAB}if minValue &gt; b {{CRLF}{TAB}{TAB}minValue = b{CRLF}{TAB}{TAB}argMin = 1{CRLF}{TAB}}{CRLF}{TAB}if minValue &gt; c {{CRLF}{TAB}{TAB}minValue = c{CRLF}{TAB}{TAB}argMin = 2{CRLF}{TAB}}{CRLF}{TAB}// evaluate maxValue(a,b,c) and argMax(a,b,c){CRLF}{TAB}maxValue := a{CRLF}{TAB}argMax := 0{CRLF}{TAB}if maxValue &lt; b {{CRLF}{TAB}{TAB}maxValue = b{CRLF}{TAB}{TAB}argMax = 1{CRLF}{TAB}}{CRLF}{TAB}if maxValue &lt; c {{CRLF}{TAB}{TAB}maxValue = c{CRLF}{TAB}{TAB}argMax = 2{CRLF}{TAB}}{CRLF}{TAB}// evaluate midleValue(a,b,c){CRLF}{TAB}midleValue := c{CRLF}{TAB}if 0 != argMin &amp;&amp; 0 != argMax {{CRLF}{TAB}{TAB}midleValue = a{CRLF}{TAB}}{CRLF}{TAB}if 1 != argMin &amp;&amp; 1 != argMax {{CRLF}{TAB}{TAB}midleValue = b{CRLF}{TAB}}{CRLF}{TAB}// evaluate midrange1 and midrange2{CRLF}{TAB}midrange1 := (minValue + midleValue)/2.0{CRLF}{TAB}midrange2 := (midleValue + maxValue)/2.0{CRLF}{CRLF}{TAB}var outVal float64{CRLF}{TAB}if d &lt; minValue { {CRLF}{TAB}{TAB}outVal = 0.0{CRLF}{TAB}} else if d &gt;= minValue &amp;&amp; d &lt; midrange1 { {CRLF}{TAB}{TAB}outVal = 1.0{CRLF}{TAB}} else if d &gt;= midrange1 &amp;&amp; d &lt; midleValue { {CRLF}{TAB}{TAB}outVal = 2.0{CRLF}{TAB}} else if d &gt;= midleValue &amp;&amp; d &lt; midrange2 { {CRLF}{TAB}{TAB}outVal = 3.0{CRLF}{TAB}} else if d &gt;= midrange2 &amp;&amp; d &lt; maxValue { {CRLF}{TAB}{TAB}outVal = 4.0{CRLF}{TAB}} else if d &gt;= maxValue { {CRLF}{TAB}{TAB}outVal = 5.0{CRLF}{TAB}}{CRLF}{TAB}return outVal{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ECL3A">func gepECL3A(x, y, z float64) float64 {{CRLF}{TAB}if y &gt; x &amp;&amp; z &lt; x {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  y &lt; x &amp;&amp; z &gt; x {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ECL3B">func gepECL3B(x, y, z float64) float64 {{CRLF}{TAB}if y &gt; x &amp;&amp; z &gt; x {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  y &lt; x &amp;&amp; z &lt; x {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ECL3C">func gepECL3C(x, y, z float64) float64 {{CRLF}{TAB}if y &gt;= x &amp;&amp; z &gt;= x {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  y &lt;= -x &amp;&amp; z &lt;= -x {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ECL3D">func gepECL3D(a, b, c, d float64) float64 {{CRLF}{TAB}minValue := math.Min(a,b){CRLF}{TAB}maxValue := math.Max(a,b){CRLF}{TAB}if c &gt;= maxValue &amp;&amp; d &gt;= maxValue {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  c &lt;= minValue &amp;&amp; d &lt;= minValue {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AMin2">func gepAMin2(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AMin3">func gepAMin3(x, y, z float64) float64 {{CRLF}{TAB}temp := x{CRLF}{TAB}var argMin float64{CRLF}{TAB}if temp &gt;= y {{CRLF}{TAB}{TAB}temp = y{CRLF}{TAB}{TAB}argMin = 1.0{CRLF}{TAB}}{CRLF}{TAB}if temp &gt;= z {{CRLF}{TAB}{TAB}argMin = 2.0{CRLF}{TAB}}{CRLF}{TAB}return argMin{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AMin4">func gepAMin4(a, b, c, d float64) float64 {{CRLF}{TAB}temp := a{CRLF}{TAB}var argMin float64{CRLF}{TAB}if temp &gt;= b {{CRLF}{TAB}{TAB}temp = b{CRLF}{TAB}{TAB}argMin = 1.0{CRLF}{TAB}}{CRLF}{TAB}if temp &gt;= c {{CRLF}{TAB}{TAB}temp = c{CRLF}{TAB}{TAB}argMin = 2.0{CRLF}{TAB}}{CRLF}{TAB}if temp &gt;= d {{CRLF}{TAB}{TAB}argMin = 3.0{CRLF}{TAB}}{CRLF}{TAB}return argMin{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AMax2">func gepAMax2(x, y float64) float64 {{CRLF}{TAB}if x &gt;= y {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AMax3">func gepAMax3(x, y, z float64) float64 {{CRLF}{TAB}temp := x{CRLF}{TAB}var argMax float64{CRLF}{TAB}if temp &lt; y {{CRLF}{TAB}{TAB}temp = y{CRLF}{TAB}{TAB}argMax = 1.0{CRLF}{TAB}}{CRLF}{TAB}if temp &lt; z {{CRLF}{TAB}{TAB}argMax = 2.0{CRLF}{TAB}}{CRLF}{TAB}return argMax{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AMax4">func gepAMax4(a, b, c, d float64) float64 {{CRLF}{TAB}temp := a{CRLF}{TAB}var argMax float64{CRLF}{TAB}if temp &lt; b {{CRLF}{TAB}{TAB}temp = b{CRLF}{TAB}{TAB}argMax = 1.0{CRLF}{TAB}}{CRLF}{TAB}if temp &lt; c {{CRLF}{TAB}{TAB}temp = c{CRLF}{TAB}{TAB}argMax = 2.0{CRLF}{TAB}}{CRLF}{TAB}if temp &lt; d {{CRLF}{TAB}{TAB}argMax = 3.0{CRLF}{TAB}}{CRLF}{TAB}return argMax{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="OR1">func gepOR1(x, y float64) float64 {{CRLF}{TAB}if (x &lt; 0.0) || (y &lt; 0.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="OR2">func gepOR2(x, y float64) float64 {{CRLF}{TAB}if (x &gt;= 0.0) || (y &gt;= 0.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="OR3">func gepOR3(x, y float64) float64 {{CRLF}{TAB}if (x &lt;= 0.0) || (y &lt;= 0.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="OR4">func gepOR4(x, y float64) float64 {{CRLF}{TAB}if (x &lt; 1.0) || (y &lt; 1.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="OR5">func gepOR5(x, y float64) float64 {{CRLF}{TAB}if (x &gt;= 1.0) || (y &gt;= 1.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="OR6">func gepOR6(x, y float64) float64 {{CRLF}{TAB}if (x &lt;= 1.0) || (y &lt;= 1.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AND1">func gepAND1(x, y float64) float64 {{CRLF}{TAB}if (x &lt; 0.0) &amp;&amp; (y &lt; 0.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AND2">func gepAND2(x, y float64) float64 {{CRLF}{TAB}if (x &gt;= 0.0) &amp;&amp; (y &gt;= 0.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AND3">func gepAND3(x, y float64) float64 {{CRLF}{TAB}if (x &lt;= 0.0) &amp;&amp; (y &lt;= 0.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AND4">func gepAND4(x, y float64) float64 {{CRLF}{TAB}if (x &lt; 1.0) &amp;&amp; (y &lt; 1.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AND5">func gepAND5(x, y float64) float64 {{CRLF}{TAB}if (x &gt;= 1.0) &amp;&amp; (y &gt;= 1.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="AND6">func gepAND6(x, y float64) float64 {{CRLF}{TAB}if (x &lt;= 1.0) &amp;&amp; (y &lt;= 1.0) {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT2A">func gepLT2A(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}{TAB}return y{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT2A">func gepGT2A(x, y float64) float64 {{CRLF}{TAB}if x &gt; y {{CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}{TAB}return y{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE2A">func gepLOE2A(x, y float64) float64 {{CRLF}{TAB}if x &lt;= y {{CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}{TAB}return y{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE2A">func gepGOE2A(x, y float64) float64 {{CRLF}{TAB}if x &gt;= y {{CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}{TAB}return y{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET2A">func gepET2A(x, y float64) float64 {{CRLF}{TAB}if x == y {{CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}{TAB}return y{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET2A">func gepNET2A(x, y float64) float64 {{CRLF}{TAB}if x != y {{CRLF}{TAB}{TAB}return x{CRLF}{TAB}}{CRLF}{TAB}return y{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT2B">func gepLT2B(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT2B">func gepGT2B(x, y float64) float64 {{CRLF}{TAB}if x &gt; y {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE2B">func gepLOE2B(x, y float64) float64 {{CRLF}{TAB}if x &lt;= y {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE2B">func gepGOE2B(x, y float64) float64 {{CRLF}{TAB}if x &gt;= y {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET2B">func gepET2B(x, y float64) float64 {{CRLF}{TAB}if x == y {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET2B">func gepNET2B(x, y float64) float64 {{CRLF}{TAB}if x != y {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}{TAB}return 0.0{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT2C">func gepLT2C(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT2C">func gepGT2C(x, y float64) float64 {{CRLF}{TAB}if x &gt; y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE2C">func gepLOE2C(x, y float64) float64 {{CRLF}{TAB}if x &lt;= y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE2C">func gepGOE2C(x, y float64) float64 {{CRLF}{TAB}if x &gt;= y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET2C">func gepET2C(x, y float64) float64 {{CRLF}{TAB}if x == y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET2C">func gepNET2C(x, y float64) float64 {{CRLF}{TAB}if x != y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT2D">func gepLT2D(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT2D">func gepGT2D(x, y float64) float64 {{CRLF}{TAB}if x &gt; y {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE2D">func gepLOE2D(x, y float64) float64 {{CRLF}{TAB}if x &lt;= y {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE2D">func gepGOE2D(x, y float64) float64 {{CRLF}{TAB}if x &gt;= y {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET2D">func gepET2D(x, y float64) float64 {{CRLF}{TAB}if x == y {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET2D">func gepNET2D(x, y float64) float64 {{CRLF}{TAB}if x != y {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT2E">func gepLT2E(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT2E">func gepGT2E(x, y float64) float64 {{CRLF}{TAB}if x &gt; y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE2E">func gepLOE2E(x, y float64) float64 {{CRLF}{TAB}if x &lt;= y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE2E">func gepGOE2E(x, y float64) float64 {{CRLF}{TAB}if x &gt;= y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET2E">func gepET2E(x, y float64) float64 {{CRLF}{TAB}if x == y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET2E">func gepNET2E(x, y float64) float64 {{CRLF}{TAB}if x != y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT2F">func gepLT2F(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT2F">func gepGT2F(x, y float64) float64 {{CRLF}{TAB}if x &gt; y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE2F">func gepLOE2F(x, y float64) float64 {{CRLF}{TAB}if x &lt;= y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE2F">func gepGOE2F(x, y float64) float64 {{CRLF}{TAB}if x &gt;= y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET2F">func gepET2F(x, y float64) float64 {{CRLF}{TAB}if x == y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET2F">func gepNET2F(x, y float64) float64 {{CRLF}{TAB}if x != y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT2G">func gepLT2G(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT2G">func gepGT2G(x, y float64) float64 {{CRLF}{TAB}if x &gt; y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE2G">func gepLOE2G(x, y float64) float64 {{CRLF}{TAB}if x &lt;= y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE2G">func gepGOE2G(x, y float64) float64 {{CRLF}{TAB}if x &gt;= y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET2G">func gepET2G(x, y float64) float64 {{CRLF}{TAB}if x == y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET2G">func gepNET2G(x, y float64) float64 {{CRLF}{TAB}if x != y {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3A">func gepLT3A(x, y, z float64) float64 {{CRLF}{TAB}if x &lt; 0.0 {{CRLF}{TAB}{TAB}return y{CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3A">func gepGT3A(x, y, z float64) float64 {{CRLF}{TAB}if x &gt; 0.0 {{CRLF}{TAB}{TAB}return y{CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3A">func gepLOE3A(x, y, z float64) float64 {{CRLF}{TAB}if x &lt;= 0.0 {{CRLF}{TAB}{TAB}return y{CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3A">func gepGOE3A(x, y, z float64) float64 {{CRLF}{TAB}if x &gt;= 0.0 {{CRLF}{TAB}{TAB}return y{CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3A">func gepET3A(x, y, z float64) float64 {{CRLF}{TAB}if x == 0.0 {{CRLF}{TAB}{TAB}return y{CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3A">func gepNET3A(x, y, z float64) float64 {{CRLF}{TAB}if x != 0.0 {{CRLF}{TAB}{TAB}return y{CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3B">func gepLT3B(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3B">func gepGT3B(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3B">func gepLOE3B(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3B">func gepGOE3B(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3B">func gepET3B(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3B">func gepNET3B(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return z{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3C">func gepLT3C(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3C">func gepGT3C(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3C">func gepLOE3C(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3C">func gepGOE3C(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3C">func gepET3C(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3C">func gepNET3C(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3D">func gepLT3D(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3D">func gepGT3D(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3D">func gepLOE3D(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3D">func gepGOE3D(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3D">func gepET3D(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3D">func gepNET3D(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3E">func gepLT3E(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3E">func gepGT3E(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3E">func gepLOE3E(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3E">func gepGOE3E(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3E">func gepET3E(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3E">func gepNET3E(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3F">func gepLT3F(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3F">func gepGT3F(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3F">func gepLOE3F(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3F">func gepGOE3F(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3F">func gepET3F(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3F">func gepNET3F(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x + y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3G">func gepLT3G(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3G">func gepGT3G(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3G">func gepLOE3G(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3G">func gepGOE3G(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3G">func gepET3G(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3G">func gepNET3G(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x + z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3H">func gepLT3H(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3H">func gepGT3H(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3H">func gepLOE3H(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3H">func gepGOE3H(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3H">func gepET3H(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3H">func gepNET3H(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x - z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3I">func gepLT3I(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3I">func gepGT3I(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3I">func gepLOE3I(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3I">func gepGOE3I(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3I">func gepET3I(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3I">func gepNET3I(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3J">func gepLT3J(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3J">func gepGT3J(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3J">func gepLOE3J(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3J">func gepGOE3J(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3J">func gepET3J(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3J">func gepNET3J(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x * y){CRLF}{TAB}}{CRLF}{TAB}return (x / z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3K">func gepLT3K(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3K">func gepGT3K(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3K">func gepLOE3K(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3K">func gepGOE3K(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3K">func gepET3K(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3K">func gepNET3K(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT3L">func gepLT3L(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt; z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT3L">func gepGT3L(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt; z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE3L">func gepLOE3L(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &lt;= z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE3L">func gepGOE3L(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) &gt;= z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET3L">func gepET3L(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) == z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET3L">func gepNET3L(x, y, z float64) float64 {{CRLF}{TAB}if (x + y) != z {{CRLF}{TAB}{TAB}return (x + y + z){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(x * y * z){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4A">func gepLT4A(a, b, c, d float64) float64 {{CRLF}{TAB}if a &lt; b {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4A">func gepGT4A(a, b, c, d float64) float64 {{CRLF}{TAB}if a &gt; b {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4A">func gepLOE4A(a, b, c, d float64) float64 {{CRLF}{TAB}if a &lt;= b {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4A">func gepGOE4A(a, b, c, d float64) float64 {{CRLF}{TAB}if a &gt;= b {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4A">func gepET4A(a, b, c, d float64) float64 {{CRLF}{TAB}if a == b {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4A">func gepNET4A(a, b, c, d float64) float64 {{CRLF}{TAB}if a != b {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4B">func gepLT4B(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4B">func gepGT4B(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4B">func gepLOE4B(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4B">func gepGOE4B(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4B">func gepET4B(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4B">func gepNET4B(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return c{CRLF}{TAB}}{CRLF}{TAB}return d{CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4C">func gepLT4C(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4C">func gepGT4C(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4C">func gepLOE4C(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4C">func gepGOE4C(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4C">func gepET4C(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4C">func gepNET4C(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4D">func gepLT4D(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4D">func gepGT4D(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4D">func gepLOE4D(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4D">func gepGOE4D(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4D">func gepET4D(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4D">func gepNET4D(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4E">func gepLT4E(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4E">func gepGT4E(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4E">func gepLOE4E(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4E">func gepGOE4E(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4E">func gepET4E(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4E">func gepNET4E(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4F">func gepLT4F(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4F">func gepGT4F(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4F">func gepLOE4F(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4F">func gepGOE4F(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4F">func gepET4F(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4F">func gepNET4F(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return (a + b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4G">func gepLT4G(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4G">func gepGT4G(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4G">func gepLOE4G(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4G">func gepGOE4G(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4G">func gepET4G(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4G">func gepNET4G(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c + d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4H">func gepLT4H(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4H">func gepGT4H(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4H">func gepLOE4H(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4H">func gepGOE4H(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4H">func gepET4H(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4H">func gepNET4H(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c - d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4I">func gepLT4I(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4I">func gepGT4I(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4I">func gepLOE4I(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4I">func gepGOE4I(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4I">func gepET4I(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4I">func gepNET4I(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4J">func gepLT4J(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4J">func gepGT4J(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4J">func gepLOE4J(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4J">func gepGOE4J(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4J">func gepET4J(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4J">func gepNET4J(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return (a * b){CRLF}{TAB}}{CRLF}{TAB}return (c / d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4K">func gepLT4K(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return math.Sin(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4K">func gepGT4K(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return math.Sin(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4K">func gepLOE4K(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return math.Sin(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4K">func gepGOE4K(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return math.Sin(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4K">func gepET4K(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return math.Sin(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4K">func gepNET4K(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return math.Sin(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Sin(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LT4L">func gepLT4L(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt; (c + d) {{CRLF}{TAB}{TAB}return math.Atan(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GT4L">func gepGT4L(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt; (c + d) {{CRLF}{TAB}{TAB}return math.Atan(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="LOE4L">func gepLOE4L(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &lt;= (c + d) {{CRLF}{TAB}{TAB}return math.Atan(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="GOE4L">func gepGOE4L(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) &gt;= (c + d) {{CRLF}{TAB}{TAB}return math.Atan(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="ET4L">func gepET4L(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) == (c + d) {{CRLF}{TAB}{TAB}return math.Atan(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(c * d){CRLF}}{CRLF}{CRLF}</helper>
    <helper replaces="NET4L">func gepNET4L(a, b, c, d float64) float64 {{CRLF}{TAB}if (a + b) != (c + d) {{CRLF}{TAB}{TAB}return math.Atan(a * b){CRLF}{TAB}}{CRLF}{TAB}return math.Atan(c * d){CRLF}}{CRLF}{CRLF}</helper>
  </helpers>
  <keywords>
    <keyword>float64</keyword>
    <keyword>int</keyword>
    <keyword>string</keyword>
    <keyword>if</keyword>
    <keyword>else</keyword>
    <keyword>return</keyword>
    <keyword>const</keyword>
    <keyword>make</keyword>
    <keyword>import</keyword>
    <keyword>package</keyword>
    <keyword>switch</keyword>
    <keyword>case</keyword>
    <keyword>default</keyword>
    <keyword>break</keyword>
    <keyword>func</keyword>
    <keyword>char</keyword>
    <keyword>nil</keyword>
  </keywords>
  <commentmark>//</commentmark>
  <linkingFunctions count="6">
    <linkingFunction replaces="CL2A">func gepCL2A(x, y float64) float64 {{CRLF}{TAB}if x &gt; 0.0 &amp;&amp; y &gt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</linkingFunction>
    <linkingFunction replaces="CL2D">func gepCL2D(x, y float64) float64 {{CRLF}{TAB}if x &gt; 0.0 &amp;&amp; y &gt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</linkingFunction>
    <linkingFunction replaces="CL3A">func gepCL3A(x, y float64) float64 {{CRLF}{TAB}if x &gt; 0.0 &amp;&amp; y &lt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  x &lt; 0.0 &amp;&amp; y &gt; 0.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</linkingFunction>
    <linkingFunction replaces="CL3B">func gepCL3B(x, y float64) float64 {{CRLF}{TAB}if x &gt;= 1.0 &amp;&amp; y &gt;= 1.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  x &lt;= -1.0 &amp;&amp; y &lt;= -1.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</linkingFunction>
    <linkingFunction replaces="CL3C">func gepCL3C(x, y float64) float64 {{CRLF}{TAB}if x &gt; 0.0 &amp;&amp; y &gt; 0.0 {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}} else if  x &lt; 0.0 &amp;&amp; y &lt; 0.0 {{CRLF}{TAB}{TAB}return -1.0{CRLF}{TAB}} else { {CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</linkingFunction>
    <linkingFunction replaces="AMin2">func gepAMin2(x, y float64) float64 {{CRLF}{TAB}if x &lt; y {{CRLF}{TAB}{TAB}return 0.0{CRLF}{TAB}} else {{CRLF}{TAB}{TAB}return 1.0{CRLF}{TAB}}{CRLF}}{CRLF}{CRLF}</linkingFunction>
  </linkingFunctions>
  <ddfcomment>// Add a DDF with the name {FUNCTION_SYMBOL} in {LANGUAGE}{CRLF}// and a parameter list equivalent to {PARAMETER_LIST}{CRLF}</ddfcomment>
  <udfcomment>// Add a UDF with the name {FUNCTION_SYMBOL} in {LANGUAGE}{CRLF}</udfcomment>
  <testing>
    <prototype paramsformat="float64 x{INDEX}">float64 {name}({params}) {{CRLF}{TAB}return {body}{CRLF}}{CRLF}{CRLF}</prototype>
    <method callformat="printf(&quot;%f\n&quot;, {method}({params})){CRLF}" listformat="{data}">import ({CRLF}{TAB}"math"{CRLF}){CRLF}{HELPERS}{CRLF}{CRLF}{FUNCTIONS}{CRLF}{CRLF}func main() {{CRLF}{CALLS}{CRLF}}{CRLF}</method>
  </testing>
</grammar>
